/*
 * generated by Xtext 2.19.0
 */
package org.xtext.computationalmodelling.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.computationalmodelling.dataflow.DataflowModel
import org.xtext.computationalmodelling.dataflow.Edge
import org.xtext.computationalmodelling.DataflowSupport

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DataflowGeneratorGraphviz extends AbstractGenerator {


	@Inject extension IQualifiedNameProvider

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {


	        for (m : resource.allContents.toIterable.filter(DataflowModel)) {
			var ds = new DataflowSupport()
			ds.getChannelNames(m)
			ds.extractActorProperties(m)
			ds.extractInputOutputNames(m)
			ds.extractChannelProperties(m)
			ds.determinePortNames(m)
		        fsa.generateFile(
				m.fullyQualifiedName.toString("/") + ".dot",
				m.compile(ds)                
			)
		}
	}

	def compile(DataflowModel m, DataflowSupport ds) '''
		digraph «m.name» {
		rankdir="LR";
		graph [bgcolor=transparent,overlap=false]
		node [fontsize=20 fontname="Calibri" fillcolor="#FDF498" width=0.6 penwidth=2 style=filled shape=circle]
		edge [fontsize=16 fontname="Calibri"]
			«this.compileActors(m, ds)»
			«this.compileInputs(m, ds)»
			«this.compileOutputs(m, ds)»
			«this.compileGraph(m, ds)»
		}
    '''

	def compileActors(DataflowModel m, DataflowSupport ds) '''
		«FOR a: ds.setOfActors(m)»
			«a» [label="«a»\n«ds.getExecutionTime(a)»"]
		«ENDFOR»
		
    '''

	def compileInputs(DataflowModel m, DataflowSupport ds) '''
		«FOR i:m.inputs»
			«i.name» [shape=point, label="«i.name»", fillcolor="#000000" width=0.05 style=filled]
		«ENDFOR»
		
    '''

	def compileOutputs(DataflowModel m, DataflowSupport ds) '''
		«FOR o:m.outputs»
			«o.name» [shape=point, label="«o.name»", fillcolor="#000000" width=0.05 style=filled]
		«ENDFOR»
		
    '''

	def compileGraph(DataflowModel m, DataflowSupport ds) '''
		«FOR e:m.edges»
			«this.compileEdge(m, e, ds)»
		«ENDFOR»
		
    '''

	def String prodLabel(Edge e) {
	}

	def compileInputEdge(Edge e, DataflowSupport ds) '''
		«e.srcact.name» -> «e.dstact.name» [minlen=1 len=1 xlabel="" headlabel="" taillabel="«e.srcact.name»"]
    '''

	def compileOutputEdge(Edge e, DataflowSupport ds) '''
		«e.srcact.name» -> «e.dstact.name» [minlen=1 len=1 xlabel="" headlabel="«e.dstact.name»" taillabel=""]
    '''

	def compileRegularEdge(Edge e, DataflowSupport ds) '''
				«e.srcact.name» -> «e.dstact.name» [minlen=3 len=3 xlabel="«ds.getInitialTokens(e).toString»" headlabel="«ds.getConsRate(e).toString»" taillabel="«ds.getProdRate(e).toString»"]
    '''


	def compileEdge(DataflowModel m, Edge e, DataflowSupport ds) '''
		«IF ds.inputNames.contains(e.srcact.name)»
			«compileInputEdge(e, ds)»
		«ELSE»
			«IF ds.outputNames.contains(e.dstact.name)»
				«compileOutputEdge(e, ds)»
			«ELSE»
				«compileRegularEdge(e, ds)»
			«ENDIF»
		«ENDIF»
    '''
}
