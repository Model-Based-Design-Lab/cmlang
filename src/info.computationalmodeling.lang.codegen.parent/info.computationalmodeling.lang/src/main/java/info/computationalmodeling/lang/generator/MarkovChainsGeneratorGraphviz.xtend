/*
 * generated by Xtext 2.19.0
 */
package info.computationalmodeling.lang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import info.computationalmodeling.lang.markovchains.MarkovChainModel
import info.computationalmodeling.lang.MarkovChainSupport
import info.computationalmodeling.lang.markovchains.Edge

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MarkovChainsGeneratorGraphviz extends AbstractGenerator {


	@Inject extension IQualifiedNameProvider

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        for (m : resource.allContents.toIterable.filter(MarkovChainModel)) {
			var ds = new MarkovChainSupport()
			ds.extractProperties(m)
	        fsa.generateFile(
	            m.fullyQualifiedName.toString("/") + ".dot",
	            m.compile(ds))                
        }
	}


	def compile(MarkovChainModel m, MarkovChainSupport ds) '''
		digraph «m.name» {
		rankdir="LR";
		graph [bgcolor=transparent]
		node [fontsize=20 fontname="Calibri" fillcolor="#F498FD" width=0.6 penwidth=2 style=filled shape=circle]
		edge [fontsize=16 fontname="Calibri"]
			«this.compileGraph(m, ds)»
		}
    '''

	def compileGraph(MarkovChainModel m, MarkovChainSupport ds) '''
		«FOR e:m.edges»
			«this.compileEdge(e, ds)»
		«ENDFOR»
		
    '''

	def compileEdge(Edge e, MarkovChainSupport ds) '''
		"«e.srcstate.name»" -> "«e.dststate.name»" [label="«MarkovChainSupport.probabilityLabel(e)»" ]
    '''

//	def compileEdge(Edge e, MarkovChainSupport ds) '''
//		"«ds.graphVizStateLabel(e.srcstate)»" -> "«ds.graphVizStateLabel(e.dststate)»" [label="«MarkovChainSupport.probabilityLabel(e)»" ]
//    '''


}
