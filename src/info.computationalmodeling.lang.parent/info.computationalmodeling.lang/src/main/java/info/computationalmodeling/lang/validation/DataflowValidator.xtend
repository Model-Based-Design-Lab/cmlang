/*
 * generated by Xtext 2.19.0
 */
package info.computationalmodeling.lang.validation

import info.computationalmodeling.lang.dataflow.DataflowModel
import info.computationalmodeling.lang.dataflow.DataflowPackage
import java.util.Set
import java.util.HashSet
import info.computationalmodeling.lang.dataflow.Edge
import org.eclipse.xtext.validation.Check
import info.computationalmodeling.lang.dataflow.EdgeAnnotation
import java.util.HashMap
import java.util.ArrayList
import java.util.Map
//import org.apache.commons.math.fraction.Fraction
import org.apache.commons.math3.fraction.Fraction

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DataflowValidator extends AbstractDataflowValidator {
	
	
	def Set<String> setOfActors(DataflowModel m){
		var result = new HashSet<String>;
		for(Edge e: m.edges) {
			result.add(e.srcact.name)
			result.add(e.dstact.name)
		}
		return result
	}
	
	def Set<String> getConnectedActors(DataflowModel m, Set<String> actors){
		var result = new HashSet<String>;
		for(Edge e: m.edges) {
			if (actors.contains(e.srcact.name) || actors.contains(e.dstact.name)) {
				result.add(e.srcact.name)
				result.add(e.dstact.name)
			}
		}
		return result
	}
	
	
	def findOneOutside(Set<String> sA, Set<String> sB){
		for (b: sB) {
			if (! sA.contains(b)) return b
		}
		return null
	}
	
	// check if the graph is connected
	// returns null if it is connected
	// returns a pair of actors names that are not connected
	def Pair<String, String> checkConnected(DataflowModel m) {
		var actors = setOfActors(m)
		if (actors.length < 2) return null
		var Set<String> connActors = new HashSet<String>()
		val actor1 = actors.get(0)
		connActors.add(actor1)
		var prevConnSize = 0
		var connSize = 1
		while (prevConnSize < connSize) {
			var newConnActors = getConnectedActors(m, connActors)
			prevConnSize = connSize
			connSize = newConnActors.length
			connActors = newConnActors								
		}
		val actor2 = findOneOutside(connActors, actors)
		if (actor2 === null) {
			return null
		}
		return new Pair<String, String>(actor1, actor2)
	}
	
	def String doubleChannelName(DataflowModel m) {
		var channels = new HashSet<String>;
		for(Edge e: m.edges) {
			for(EdgeAnnotation a: e.specs.annotations) {
				if (a.name !== null) {
					if (channels.contains(a.name)) 
					{
						return a.name
					}
					else {
						channels.add(a.name)		
					}
				}
			}
		}
		return null
	}

	def int getProdRate(Edge e) {
		for (a: e.specs.annotations) {
			if (a.prodrate != 0) {
				return a.prodrate
			}
		}
		return 1
	}
	
	def int getConsRate(Edge e) {
		for (a: e.specs.annotations) {
			if (a.consrate != 0) {
				return a.consrate
			}
		}
		return 1
	}

	def String oppositeActor(Edge e, String act) {
		if (e.srcact.name == act) 
		{
			return e.dstact.name
		}
		else
		{
			return e.srcact.name
		}
	}

	def ArrayList<Edge> makeInconsistentCycle(Map<String, Edge> backTrackEdge, String srcact, String dstact, Edge closingEdge){
		// track srcact to the root
		var currAct = srcact
		var srcList = new ArrayList<Edge>()
		var srcListActors = new HashSet<String>()
		srcListActors.add(currAct)
		while (backTrackEdge.containsKey(currAct)) {
			val e = backTrackEdge.get(currAct)
			srcList.add(e)
			currAct = oppositeActor(e, currAct)
			srcListActors.add(currAct)
		}
		// track dstact to root, stop at first intersection with first track
		currAct = dstact
		var dstList = new ArrayList<Edge>()
		while (backTrackEdge.containsKey(currAct)) {
			val e = backTrackEdge.get(currAct)
			dstList.add(e)
			currAct = oppositeActor(e, currAct)
			if (srcListActors.contains(currAct)) {
				 // quit while loop
				currAct=""
 			}
		}
		
		// make cycle out of srcList, dstList and e
		var result = new ArrayList<Edge>()
		for (e: srcList) {
			result.add(e)
		}
		for (e: dstList.reverse) {
			result.add(e)
		}
		result.add(closingEdge)
		return result
	}

	def edgeString(Edge e) { 
		val direction = "edge from " + e.srcact.name + ' to ' + e.dstact.name
		for (a: e.specs.annotations) {
			if (a.name !== null) {
				return direction + ' named ' + a.name
			}
		}
		return 'unnamed ' + direction 
	}


	def cycleString(ArrayList<Edge> cycle) {
		var res = new StringBuilder()
		for (e: cycle) {
			res.append(edgeString(e))
			res.append('; ')
		}
		return res.toString()
	}

	def checkConsistency(DataflowModel m) {

		// keep track of rate-labeled actors
		var labeledActors = new HashMap<String, Fraction>()
		
		// keep track of the edge that determined its rate
		var backTrackEdge = new HashMap<String, Edge>()
		
		// label first actor
		val act = m.edges.get(0).srcact.name
		labeledActors.put(act, new Fraction(1,1))
		
		// repeat until no new actor is labeled
		var newLabels = true
		while(newLabels) {
			newLabels = false
			for (e: m.edges) {
				if (labeledActors.containsKey(e.srcact.name) && ! labeledActors.containsKey(e.dstact.name)) 
				{
					// compute rate of dst
					labeledActors.put(e.dstact.name, labeledActors.get(e.srcact.name).multiply(new Fraction(getProdRate(e), getConsRate(e))))
					backTrackEdge.put(e.dstact.name, e)
					newLabels = true
				}
				if (!labeledActors.containsKey(e.srcact.name) && labeledActors.containsKey(e.dstact.name)) 
				{
					// compute rate of src
					labeledActors.put(e.srcact.name, labeledActors.get(e.dstact.name).multiply(new Fraction(getConsRate(e), getProdRate(e))))
					backTrackEdge.put(e.srcact.name, e)
					newLabels = true
				}
				if (labeledActors.containsKey(e.srcact.name) && labeledActors.containsKey(e.dstact.name)) 
				{
					// check consistency
					val consDstRate = labeledActors.get(e.srcact.name).multiply(new Fraction(getProdRate(e), getConsRate(e)))
					if (consDstRate != labeledActors.get(e.dstact.name)) return makeInconsistentCycle(backTrackEdge, e.srcact.name, e.dstact.name, e)
				}
			}
		}
	}
	
	
	public static val INVALID_GRAPH = 'disconnectedGraph'
	public static val INVALID_NAME = 'invalidName'


	@Check
	// - check that channel names are unique
	def checkChannelNamesUniqe(DataflowModel m) {
		val chan = doubleChannelName(m)
		if (chan !== null) {
			error('The graph contains multiple channels named ' + chan + '.', 
					DataflowPackage.Literals.DATAFLOW_MODEL__EDGES,
					INVALID_NAME)
		}
	}


	@Check
	// - check that graph is connected
	def checkGraphIsConnected(DataflowModel m) {
		val conn = checkConnected(m)
		if (conn !== null) {
			warning('The graph is not connected. There is no path between ' + conn.key +' and ' + conn.value + '.', 
					DataflowPackage.Literals.DATAFLOW_MODEL__EDGES,
					INVALID_GRAPH)
		}
	}

	@Check
	// - check that graph is consistent
	def checkGraphIsConsistent(DataflowModel m) {
		val cycle = checkConsistency(m)
		if (cycle !== null) {
			val inconsistentCycle = cycleString(cycle)
			warning('The graph is not consistent. There is an inconsistent cycle: ' + inconsistentCycle + '.', 
					DataflowPackage.Literals.DATAFLOW_MODEL__EDGES,
					INVALID_GRAPH)
		}
	}

	
}
